### Домашнее задание 4. Implementor

1.  Реализуйте класс `Implementor`, генерирующий реализации классов и интерфейсов.
    *   Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
    *   В результате работы должен быть сгенерирован java-код класса с суффиксом `Impl`, расширяющий (реализующий) указанный класс (интерфейс).
    *   Сгенерированный класс должен компилироваться без ошибок.
    *   Сгенерированный класс не должен быть абстрактным.
    *   Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2.  В задании выделяются три варианта:
    *   _Простой_ — `Implementor` должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
    *   _Сложный_ — `Implementor` должен уметь реализовывать и классы, и интерфейсы. Поддержка generics не требуется.
    *   _Бонусный_ — `Implementor` должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов и не порождать `UncheckedWarning`.

### Домашнее задание 5. Jar Implementor

Это домашнее задание **связано** с предыдущим и будет приниматься только с ним. Предыдущее домашнее задание отдельно сдать будет нельзя.

1.  Создайте `.jar`\-файл, содержащий скомпилированный `Implementor` и сопутствующие классы.
    *   Созданный `.jar`\-файл должен запускаться командой `java -jar`.
    *   Запускаемый `.jar`\-файл должен принимать те же аргументы командной строки, что и класс `Implementor`.
2.  Модифицируйте `Implemetor` так, чтобы при запуске с аргументами `-jar имя-класса файл.jar` он генерировал `.jar`\-файл с реализацией соответствующего класса (интерфейса).
3.  Для проверки, кроме исходного кода так же должны быть представлены:
    *   скрипт для создания запускаемого `.jar`\-файла, в том числе исходный код манифеста;
    *   запускаемый `.jar`\-файл.
4.  **Сложный вариант**. Решение должно быть модуляризовано.

### Домашнее задание 6. Javadoc

Это домашнее задание **связано** с двумя предыдущими и будет приниматься только с ними. Предыдущие домашнее задание отдельно сдать будет нельзя.

1.  Документируйте класс `Implementor` и сопутствующие классы с применением Javadoc.
    *   Должны быть документированы все классы и все члены классов, в том числе `private`.
    *   Документация должна генерироваться без предупреждений.
    *   Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
2.  Для проверки, кроме исходного кода так же должны быть представлены:
    * скрипт для генерации документации;
    * сгенерированная документация.

#### Домашнее задание 7. Итеративный параллелизм

1.  Реализуйте класс `IterativeParallelism`, который будет обрабатывать списки в несколько потоков.
2.  В простом варианте должны быть реализованы следующие методы:
    *   `minimum(threads, list, comparator)` — первый минимум;
    *   `maximum(threads, list, comparator)` — первый максимум;
    *   `all(threads, list, predicate)` — проверка, что все элементы списка, удовлетворяют предикату;
    *   `any(threads, list, predicate)` — проверка, что существует элемент списка, удовлетворяющий предикату.
    *   `count(threads, list, predicate)` — подсчёт числа элементов списка, удовлетворяющих предикату.
3.  В сложном варианте должны быть дополнительно реализованы следующие методы:
    *   `filter(threads, list, predicate)` — вернуть список, содержащий элементы удовлетворяющие предикату;
    *   `map(threads, list, function)` — вернуть список, содержащий результаты применения функции;
    *   `join(threads, list)` — конкатенация строковых представлений элементов списка.
4.  Во все функции передается параметр `threads` — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков относительно мало.
5.  Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6.  При выполнении задания **нельзя** использовать _Concurrency Utilities_.

#### Домашнее задание 8. Параллельный запуск

1.  Напишите класс `ParallelMapperImpl`, реализующий интерфейс `ParallelMapper`.

    public interface ParallelMapper extends AutoCloseable {
    <T, R> List<R> map(
    Function<? super T, ? extends R> f,
    List<? extends T> args
    ) throws InterruptedException;

        @Override
        void close();
    }

    *   Метод `map` должен параллельно вычислять функцию `f` на каждом из указанных аргументов (`args`).
    *   Метод `close` должен останавливать все рабочие потоки.
    *   Конструктор `ParallelMapperImpl(int threads)` создает `threads` рабочих потоков, которые могут быть использованы для распараллеливания.
    *   К одному `ParallelMapperImpl` могут одновременно обращаться несколько клиентов.
    *   Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
    *   В реализации не должно быть активных ожиданий.
2.  Доработайте класс `IterativeParallelism` так, чтобы он мог использовать `ParallelMapper`.
    *   Добавьте конструктор `IterativeParallelism(ParallelMapper)`
    *   Методы класса должны делить работу на `threads` фрагментов и исполнять их при помощи `ParallelMapper`.
    *   При наличии `ParallelMapper` сам `IterativeParallelism` новые потоки создавать не должен.
    *   Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один `ParallelMapper`.
3.  При выполнении задания всё ещё **нельзя** использовать _Concurrency Utilities_.

#### Домашнее задание 9. Web Crawler

1.  Напишите потокобезопасный класс `WebCrawler`, который будет рекурсивно обходить сайты.
    1.  Класс `WebCrawler` должен иметь конструктор

        public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)

        *   `downloader` позволяет скачивать страницы и извлекать из них ссылки;
        *   `downloaders` — максимальное число одновременно загружаемых страниц;
        *   `extractors` — максимальное число страниц, из которых одновременно извлекаются ссылки;
        *   `perHost` — максимальное число страниц, одновременно загружаемых c одного хоста. Для определения хоста следует использовать метод `getHost` класса `URLUtils` из тестов.
    2.  Класс `WebCrawler` должен реализовывать интерфейс `Crawler`

        public interface Crawler extends AutoCloseable {
        Result download(String url, int depth);

            void close();
        }

        *   Метод `download` должен рекурсивно обходить страницы, начиная с указанного URL, на указанную глубину и возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она ссылается, и так далее.
        *   Метод `download` может вызываться параллельно в нескольких потоках.
        *   Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых загружаются ссылки.
        *   Для распараллеливания разрешается создать до `downloaders + extractors` вспомогательных потоков.
        *   Повторно загружать и/или извлекать ссылки из одной и той же страницы в рамках одного обхода (`download`) запрещается.
        *   Метод `close` должен завершать все вспомогательные потоки.
    3.  Для загрузки страниц должен применяться `Downloader`, передаваемый первым аргументом конструктора.

        public interface Downloader {
        public Document download(final String url) throws IOException;
        }

        *   Метод `download` загружает документ по его адресу ([URL](http://tools.ietf.org/html/rfc3986)).
        *   Документ позволяет получить ссылки по загруженной странице:

            public interface Document {
            List<String> extractLinks() throws IOException;
            }

            Ссылки, возвращаемые документом, являются абсолютными и имеют схему `http` или `https`.
    4.  Должен быть реализован метод `main`, позволяющий запустить обход из командной строки
        *   Командная строка

            WebCrawler url \[depth \[downloads \[extractors \[perHost\]\]\]\]

        *   Для загрузки страниц требуется использовать реализацию `CachingDownloader` из тестов.
2.  Версии задания
    1.  _Простая_ — не требуется учитывать ограничения на число одновременных закачек с одного хоста (`perHost >= downloaders`).
    2.  _Полная_ — требуется учитывать все ограничения.
    3.  _Бонусная_ — сделать параллельный обход в ширину.
3.  Задание подразумевает активное использование Concurrency Utilities, в частности, в решении не должно быть «велосипедов», аналогичных/легко сводящихся к классам из Concurrency Utilities.

#### Домашнее задание 10. HelloUDP

1.  Реализуйте клиент и сервер, взаимодействующие по UDP.
2.  Класс HelloUDPClient должен отправлять запросы на сервер, принимать результаты и выводить их на консоль.
    *   Аргументы командной строки:
        1.  имя или ip-адрес компьютера, на котором запущен сервер;
        2.  номер порта, на который отсылать запросы;
        3.  префикс запросов (строка);
        4.  число параллельных потоков запросов;
        5.  число запросов в каждом потоке.
    *   Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заново.
    *   Запросы должны формироваться по схеме <префикс запросов><номер потока>\_<номер запроса в потоке>.
3.  Класс HelloUDPServer должен принимать задания, отсылаемые классом HelloUDPClient и отвечать на них.
    *   Аргументы командной строки:
        1.  номер порта, по которому будут приниматься запросы;
        2.  число рабочих потоков, которые будут обрабатывать запросы.
    *   Ответом на запрос должно быть Hello, <текст запроса>.
    *   Несмотря на то, что текущий способ получения ответа по запросу очень прост, сервер должен быть рассчитан на ситуацию, когда этот процесс может требовать много ресурсов и времени.
    *   Если сервер не успевает обрабатывать запросы, прием запросов может быть временно приостановлен.

#### Домашнее задание 11. Физические лица

1.  Добавьте к банковскому приложению возможность работы с физическими лицами.
    1.  У физического лица (`Person`) можно запросить имя, фамилию и номер паспорта.
    2.  Удалённые физические лица (`RemotePerson`) должны передаваться при помощи удалённых объектов.
    3.  Локальные физические лица (`LocalPerson`) должны передаваться при помощи механизма сериализации, и при последующем использовании не требовать связи с сервером.
    4.  Должна быть возможность поиска физического лица по номеру паспорта, с выбором типа возвращаемого лица.
    5.  Должна быть возможность создания записи о физическом лице по его данным.
    6.  У физического лица может быть несколько счетов, к которым должен предоставляться доступ (через `Person`).
    7.  Счёту физического лица с идентификатором subId должен соответствовать банковский счёт с id вида passport:subId.
    8.  Изменения, производимые со счётом в банке (создание и изменение баланса), должны быть видны всем соответствующим `RemotePerson`, и только тем `LocalPerson`, которые были созданы после этого изменения.
    9.  Изменения в счетах, производимые через `RemotePerson`, должны сразу применяться глобально, а производимые через `LocalPerson` – только локально для этого конкретного `LocalPerson`.
2.  Реализуйте приложение, демонстрирующее работу с физическим лицами.
    1.  Аргументы командной строки: имя, фамилия, номер паспорта физического лица, номер счёта, изменение суммы счёта.
    2.  Если информация об указанном физическом лице отсутствует, то оно должно быть добавлено. В противном случае – должны быть проверены его данные.
    3.  Если у физического лица отсутствует счёт с указанным номером, то он создается с нулевым балансом.
    4.  После обновления суммы счёта новый баланс должен выводиться на консоль.
3.  Напишите тесты, проверяющие вышеуказанное поведение как банка, так и приложения.
    *   Для реализации тестов рекомендуется использовать [JUnit](https://junit.org/junit5/) ([Tutorial](https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-our-first-test-class/)). Множество примеров использования можно найти в тестах.
    *   Если вы знакомы с другим тестовым фреймворком (например, [TestNG](https://testng.org/)), то можете использовать его.
    *   Добавьте jar-файлы используемых библиотек в каталог `lib` вашего репозитория.
    *   _Нельзя_ использовать самописные фреймворки и тесты, запускаемые через `main`.
4.  **Сложный вариант**
    1.  На каждом счету всегда должно быть неотрицательное количество денег.
    2.  Тесты не должны рассчитывать на наличие запущенного RMI Registry.
    3.  Создайте класс `BankTests`, запускающий тесты.
    4.  Создайте скрипт, запускающий `BankTests` и возвращающий код (статус) `0` в случае успеха и `1` в случае неудачи.
    5.  Создайте скрипт, запускающий тесты с использованием стандартного подхода для вашего тестового фреймворка. Код возврата должен быть как в предыдущем пункте.
5.  Приложения и тесты должны находится в пакете `info.kgeorgiy.ja.*.bank` и его подпакетах.

#### Домашнее задание 12. HelloNonblockingUDP

1.  Реализуйте клиент и сервер, взаимодействующие по UDP, используя только неблокирующий ввод-вывод.
2.  Класс `HelloUDPNonblockingClient` должен иметь функциональность аналогичную `HelloUDPClient`, но без создания новых потоков.
3.  Класс `HelloUDPNonblockingServer` должен иметь функциональность аналогичную `HelloUDPServer`, но все операции с сокетом должны производиться в одном потоке.
4.  В реализации не должно быть активных ожиданий, в том числе через `Selector`.
5.  Обратите внимание на выделение общего кода старой и новой реализации.
6.  _Бонусный вариант_. Клиент и сервер могут перед началом работы выделить O(число потоков) памяти. Выделять дополнительную память во время работы запрещено.